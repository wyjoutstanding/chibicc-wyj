# chibicc-wyj

> 本部分为 chibicc 的学习与实现记录，采用增量开发模式，每一次提交都是可执行的程序。该项目对于学习编译有三个好处，一是反馈及时，提升成就感；二是锤炼将复杂系统分解为简单组件的思维和方法；三是能够从头构建一个能生成汇编码的编译器，打通整个流程。
> 
> **写代码前，先理解每个功能需求，然后自己先思考如何实现，再参考比较原作者的思路，最后手动独立实现。可以根据自己的思考适当更改部分内容。**

## 总体思路

总体思路：输入表达式或程序，输出X86-64的汇编代码；然后用GCC汇编器和链接器生成可执行文件，编写测试用例完成测试。

## 增量构建：表达式语句

[001]：构建一个接受整数输入，输出直接返回该整数的汇编函数。同时增加`test.sh`来完成自动化单元测试；增加`Makefile`提供项目的编译/构建/测试能力。

[002]：输入在整数基础上增加了`+`和`-`运算。

[003]：支持数字、加、减操作间存在任意数量的空白符（空格/tab/换行/回车），实现简单的`tokenize`函数，用链表存储`Token`，并仅申请内存空间而不释放（编译器属于短期运行的软件，交给操作系统一次性释放，反而能提升效率，降低编码复杂度）

[004]：打印错误信息时，指明出错位置。定义函数`error_at`完成具体打印，这是用于提示用户的信息，而`error`则是通用错误提示，例如输入参数检查等。

[005]：支持四则运算和括号的表达式。之前的代码成为tokenize，新增parser采用递归下降法构造AST，code_gen后续遍历AST生成汇编代码。至此已经初步具备编译器框架雏形，算是一个完备的计算器。注意递归下降实现的的指针记录方法（通过双指针完成两层递归间的最新token指针传递）。

[006]：增加一元`+`,`-`运算符。仅需改变parser和code_gen部分代码，注意parser过程中`unary`的生成需要递归调用自身，注意`rest`指针的使用。

[007]：增加比较`==,!=,<=,>=,<,>`运算符。修改`tokenize`，`parser`和`code_gen`三个部分，其中code_gen部分可以用打表技巧优化代码逻辑。

[008]：拆分main.c为多个模块文件，便于组织管理且提升构建效率。具体分为`tokenize.c`,`parse.c`和`codegen.c`三个实现文件，将各自共用的数据结构，工具函数，核心接口封装在头文件`chibicc_wyj.h`，便于共享访问。`Makefile`修改对应编译规则，变得更为通用。

## 分号引入支持多语句；变量引入提升复用

[009]：增加分号。多语句支持。`ispunct`包含了非空白符，非字母符的所有可打印符号。分号引入需要增加一级`expr_stmt`抽象，**每一句都是相互平行独立的**，因此需要在`Node`节点加入`next`指针来链接不同的语句，每个`stmt`都是完整的AST。生成代码时依次遍历生成每个`stmt`的汇编，最后语句的值作为返回结果。

[010]：增加变量，赋值操作。最后一个表达式作为返回值。变量识别，赋值操作识别（parse）,分词器仅需保存对应。变量怎么存？怎么读？存在堆栈中，将多个语句抽象成函数`Function`，针对每个函数，先为所有局部变量分配堆栈空间，再生成语句。变量必须要存名字，位置偏移。最简单的单字符变量，范围为`a-z`和赋值操作，假设每个变量大小均为8字节，用变量名和字符`a`的偏移作为映射，来构造堆栈的位置。生成代码时需要特别注意变量左值（在赋值操作左侧）和右值（赋值操作右侧或其余表达式中）。

[011]：识别多字符的变量。构建映射关系，根据变量被求解的顺序。具体实现为构造一个存储变量名和偏移的变量结构体，在Node中引用该变量，最后生成代码时先计算对应的变量偏移。

## 引入关键字/保留字/代码块

[012]：增加 `return` 语句。`Token` 类型统一用`TK_KEYWORD`，但关键字不多，可针对每个关键字设置一个`NodeType`。`tokenize` 中先用 `TK_IDENT` 识别关键词，最后才遍历一次将对应的关键字标记出来。`codegen` 中碰见 `return`，直接跳转到结尾，实现返回效果。

[013]：增加块语句 `{...}`。首先块是语句级别的，其次它内部包含语句或自身，因此需要和之前的表达式语句和 `return` 语句并列。在 `parse` 中首次遇到对称配对的问题，因此将其拆分为两部分语句，来表达递归。其次在构建语法树时，块内部需要将语句用 `next` 链接。生成代码是也应递归生成，类似先序遍历，形象似将一棵块树，压缩成一维的语句链。

[014]：增加空语句`;`。仅需修改 `parse`，在表达式后加上 `?` 即可，`expr_stmt  = expr? ";"`。本次简化了 `parse` 实现，可直接调用 `stmt`，因为程序最外层默认以 `{}`包裹。

## 引入控制流

[015]：增加 `If () {...} else {...}` 语句。关键在于语法 `"if" "(" expr ")" stmt ("else" stmt)?`，实现中给 `Node` 增加 `cond, then, els` 指针，分别指向对应的代码块即可。生成代码用 `cmp, jmp` 完成条件选择和逻辑控制。

[016]：增加 `for (init; cond; inc) {...}` 语句。实现和`if`类似，但稍微注意条件为空时的代码生成，不要产生条件控制语句，可以用 ` "for" "(" expr_stmt expr?; expr? ")" stmt` 实现，实际上 `expr_stmt` 等价于 `expr? ;`，但条件部分用 `expr` 表达便于空条件判断。

[017]：增加 `while(cond) {...}` 语句。直接转换成 `for` 实现，少了初始化和变量增加语句。

[018]：增加 readme，以文档记录开发过程。

# 编译器实现参考资料

[北大编译实践](https://pku-minic.github.io/online-doc/#/)：一个大佬独立撑起增量实验，词法语法分析用工具生成，代码生成手动实现

[北航miniSysY](https://buaa-se-compiling.github.io/miniSysY-tutorial/)：后端采用LLVM

[自己动手写编译器](https://pandolia.net/tinyc/index.html)：民间大佬的tinyc编译器

[清华minidecaf](https://decaf-lang.github.io/minidecaf-tutorial/)：C++或python实现

[增量构建编译器在线书](https://www.sigbus.info/compilerbook)|[GitHub - rui314/chibicc: A small C compiler](https://github.com/rui314/chibicc)：每个提交对应一个section

[plctlab/riscv-operating-system-mooc: ](https://github.com/plctlab/riscv-operating-system-mooc)：软件所《从头写一个RISC-V OS》课程配套的资源