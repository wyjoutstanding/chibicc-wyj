# chibicc-wyj

> 本部分为 chibicc 的学习与实现记录，采用增量开发模式，每一次提交都是可执行的程序。该项目对于学习编译有三个好处，一是反馈及时，提升成就感；二是锤炼将复杂系统分解为简单组件的思维和方法；三是能够从头构建一个能生成汇编码的编译器，打通整个流程。
> 
> **写代码前，先理解每个功能需求，然后自己先思考如何实现，再参考比较原作者的思路，最后手动独立实现。可以根据自己的思考适当更改部分内容。**

## 总体思路

总体思路：输入表达式或程序，输出X86-64的汇编代码；然后用GCC汇编器和链接器生成可执行文件，编写测试用例完成测试。

## 增量构建：表达式语句

[001]：构建一个接受整数输入，输出直接返回该整数的汇编函数。同时增加`test.sh`来完成自动化单元测试；增加`Makefile`提供项目的编译/构建/测试能力。

[002]：输入在整数基础上增加了`+`和`-`运算。

[003]：支持数字、加、减操作间存在任意数量的空白符（空格/tab/换行/回车），实现简单的`tokenize`函数，用链表存储`Token`，并仅申请内存空间而不释放（编译器属于短期运行的软件，交给操作系统一次性释放，反而能提升效率，降低编码复杂度）

[004]：打印错误信息时，指明出错位置。定义函数`error_at`完成具体打印，这是用于提示用户的信息，而`error`则是通用错误提示，例如输入参数检查等。

[005]：支持四则运算和括号的表达式。之前的代码成为tokenize，新增parser采用递归下降法构造AST，code_gen后续遍历AST生成汇编代码。至此已经初步具备编译器框架雏形，算是一个完备的计算器。注意递归下降实现的的指针记录方法（通过双指针完成两层递归间的最新token指针传递）。

[006]：增加一元`+`,`-`运算符。仅需改变parser和code_gen部分代码，注意parser过程中`unary`的生成需要递归调用自身，注意`rest`指针的使用。

[007]：增加比较`==,!=,<=,>=,<,>`运算符。修改`tokenize`，`parser`和`code_gen`三个部分，其中code_gen部分可以用打表技巧优化代码逻辑。

[008]：拆分main.c为多个模块文件，便于组织管理且提升构建效率。具体分为`tokenize.c`,`parse.c`和`codegen.c`三个实现文件，将各自共用的数据结构，工具函数，核心接口封装在头文件`chibicc_wyj.h`，便于共享访问。`Makefile`修改对应编译规则，变得更为通用。

## 分号引入支持多语句；变量引入提升复用

[009]：增加分号。多语句支持。`ispunct`包含了非空白符，非字母符的所有可打印符号。分号引入需要增加一级`expr_stmt`抽象，**每一句都是相互平行独立的**，因此需要在`Node`节点加入`next`指针来链接不同的语句，每个`stmt`都是完整的AST。生成代码时依次遍历生成每个`stmt`的汇编，最后语句的值作为返回结果。

[010]：增加变量，赋值操作。最后一个表达式作为返回值。变量识别，赋值操作识别（parse）,分词器仅需保存对应。变量怎么存？怎么读？存在堆栈中，将多个语句抽象成函数`Function`，针对每个函数，先为所有局部变量分配堆栈空间，再生成语句。变量必须要存名字，位置偏移。最简单的单字符变量，范围为`a-z`和赋值操作，假设每个变量大小均为8字节，用变量名和字符`a`的偏移作为映射，来构造堆栈的位置。生成代码时需要特别注意变量左值（在赋值操作左侧）和右值（赋值操作右侧或其余表达式中）。

[011]：识别多字符的变量。构建映射关系，根据变量被求解的顺序。具体实现为构造一个存储变量名和偏移的变量结构体，在Node中引用该变量，最后生成代码时先计算对应的变量偏移。

## 引入关键字/保留字/代码块

[012]：增加 `return` 语句。`Token` 类型统一用`TK_KEYWORD`，但关键字不多，可针对每个关键字设置一个`NodeType`。`tokenize` 中先用 `TK_IDENT` 识别关键词，最后才遍历一次将对应的关键字标记出来。`codegen` 中碰见 `return`，直接跳转到结尾，实现返回效果。

[013]：增加块语句 `{...}`。首先块是语句级别的，其次它内部包含语句或自身，因此需要和之前的表达式语句和 `return` 语句并列。在 `parse` 中首次遇到对称配对的问题，因此将其拆分为两部分语句，来表达递归。其次在构建语法树时，块内部需要将语句用 `next` 链接。生成代码是也应递归生成，类似先序遍历，形象似将一棵块树，压缩成一维的语句链。

[014]：增加空语句`;`。仅需修改 `parse`，在表达式后加上 `?` 即可，`expr_stmt  = expr? ";"`。本次简化了 `parse` 实现，可直接调用 `stmt`，因为程序最外层默认以 `{}`包裹。

## 引入控制流

[015]：增加 `If () {...} else {...}` 语句。关键在于语法 `"if" "(" expr ")" stmt ("else" stmt)?`，实现中给 `Node` 增加 `cond, then, els` 指针，分别指向对应的代码块即可。生成代码用 `cmp, jmp` 完成条件选择和逻辑控制。

[016]：增加 `for (init; cond; inc) {...}` 语句。实现和`if`类似，但稍微注意条件为空时的代码生成，不要产生条件控制语句，可以用 ` "for" "(" expr_stmt expr?; expr? ")" stmt` 实现，实际上 `expr_stmt` 等价于 `expr? ;`，但条件部分用 `expr` 表达便于空条件判断。

[017]：增加 `while(cond) {...}` 语句。直接转换成 `for` 实现，少了初始化和变量增加语句。

[018]：增加 readme，以文档记录开发过程。

[019]：增加 `codegen` 时的错误检查，处理语义错误。例如生成地址时的左值是常量，能给出以下具体错误信息。具体实现则在 `Node` 增加一个 `token` 指针，表明当前节点指向的 `token`。

```shell
$ ./chibicc-wyj "10=a;"
10=a; [tokenize.c:37]
^ Invalid lvalue [codegen.c:24]
```

[020]：增加一元运算符 `&` 和 `*`。分别是取变量地址和指针解引用，在 `codegen` 时取变量地址可用 `rbp+offset` 表示局部变量在栈的地址，指针解引用则直接访问并返回该地址存储的值。`tokenize` 中二者无需改动，均包含在 `TK_PUNCT` 类型中。`parse` 需要 `unary` 规则中增加处理，尤其是 `*` 存在两种意义，可表示乘法和解引用，需要根据优先级处理顺序问题。

[021]：增加指针的算术运算。假设存在指针 `dtype *p`，其有效运算规则（ref. [Pointer Arithmetic in C ](https://overiq.com/c-programming-101/pointer-arithmetic-in-c/)）为：

- 加上一个整数：`p+2 => addr(p)+sizeof(dtype)*2`，指针加上2个单位的偏移

- 减去一个整数：`p-3 => addr(p)-sizeof(dtype)*3`，指针减去3个单位的偏移

- 同类型指针相减：`p1-p2 => (addr(p1)-addr(p2))/sizeof(dtype)`，该结果为二者相差的单位个数

在实现时，`tokenize` 和 `parse` 无需改变，可在 `codegen` 遇见 `SUB` 和 `ADD` 节点时加入指针运算处理。或者直接在 `parse` 处理，指针加/减一个整数时，就插入一个乘法节点 `ND_MUL`，两个指针相减则插入除法节点 `ND_DIV`。为了能处理表达式中连续的指针运算如`(&p+2)-&p+3`，需在 `Node` 增加一个 `is_pointer` 指示当前结点是否为指针，从而支持指针计算。遇到两个指针相减的节点时，该节点 `is_pointer` 需置为 `false`，因为它们结果是普通数值，而非指针。

# 引入类型系统

[022] : 使用类型系统重构指针算术运算。首次引入类型定义系统，给每个结点增加 `Type` 类型，目前仅有 `INT, PTR` 两种类型。根据孩子结点类型来解析/推导父亲结点的类型。定义一个 `add_type` 函数，实现从一个AST根结点递归推导所有结点类型。最底层的判断规则仅不包含语句级别，具体如下：

- `add, sub, mul, div, assign`：`node->type=node->lhs->type`（获得左孩子类型）

- `eq, neq, gt, ge, lt, le, var, num`：`node->type=ty_int`（比较运算结点赋为整型，目前变量var和数值num仅有int类型）

- `addr`：`node->type=pointer_to(node->lhs->type)`（取地址结点赋为指针）

- `defer`：`node->type=node->lhs->type->base` （指针解引用指向孩子结点的基类）

重构指针运算时，仅需将之前的 `is_pointer` 用 `base` 是否为空来判断或者根据结点是否为 `PTR` 类型判断。

# 编译器实现参考资料

[北大编译实践](https://pku-minic.github.io/online-doc/#/)：一个大佬独立撑起增量实验，词法语法分析用工具生成，代码生成手动实现

[北航miniSysY](https://buaa-se-compiling.github.io/miniSysY-tutorial/)：后端采用LLVM

[自己动手写编译器](https://pandolia.net/tinyc/index.html)：民间大佬的tinyc编译器

[清华minidecaf](https://decaf-lang.github.io/minidecaf-tutorial/)：C++或python实现

[增量构建编译器在线书](https://www.sigbus.info/compilerbook)|[GitHub - rui314/chibicc: A small C compiler](https://github.com/rui314/chibicc)：每个提交对应一个section

[plctlab/riscv-operating-system-mooc: ](https://github.com/plctlab/riscv-operating-system-mooc)：软件所《从头写一个RISC-V OS》课程配套的资源